# 腾讯 wxg 面试题

## 计算属性（computed）和过滤器（filters）的区别

> **总结：**
>
> - 计算属性适用于对响应式数据进行复杂的计算或处理，并且可以缓存计算结果。
> - 过滤器适用于在模板中对数据进行简单的格式化或转换。选择使用哪种方式取决于你的具体需求和场景。

在 Vue 3 中，"计算属性（computed）"和"过滤器（filters）"是用于处理数据的两种不同方式。

1. 计算属性（computed）：
   计算属性是一种定义在 Vue 组件中的属性，它根据依赖的响应式数据进行计算，并返回一个新的值。计算属性可以缓存计算结果，在依赖数据没有发生变化时直接返回缓存的结果，提高性能。

   计算属性适合用于对响应式数据进行复杂的计算或处理。例如，当需要根据多个数据属性计算出一个衍生的值时，可以使用计算属性来实现。计算属性可以像普通属性一样在模板中使用。

   ```javascript
   export default {
     data() {
       return {
         width: 10,
         height: 5,
       };
     },
     computed: {
       area() {
         return this.width * this.height;
       },
     },
   };
   ```

   在模板中使用计算属性：

   ```html
   <template>
     <div>
       <p>Width: {{ width }}</p>
       <p>Height: {{ height }}</p>
       <p>Area: {{ area }}</p>
     </div>
   </template>
   ```

2. 过滤器（filters）：
   过滤器是一种在模板中对数据进行格式化或处理的方法。它们可以用于对文本内容、日期、数字等进行转换和格式化。过滤器通过管道符 `|` 在模板中应用于表达式的结果。

   过滤器适合用于简单的文本格式化或数据转换。例如，将文本转换为大写、格式化日期等操作都可以使用过滤器来实现。

   ```javascript
   export default {
     data() {
       return {
         message: "Hello",
         date: new Date(),
       };
     },
     filters: {
       uppercase(value) {
         return value.toUpperCase();
       },
       formatDate(value) {
         // 格式化日期的逻辑
       },
     },
   };
   ```

   在模板中使用过滤器：

   ```html
   <template>
     <div>
       <p>Message: {{ message | uppercase }}</p>
       <p>Date: {{ date | formatDate }}</p>
     </div>
   </template>
   ```

## vue 的路由是怎么携带参数的

在 Vue 3 中，使用 Vue Router 进行路由跳转并携带参数可以通过以下方式实现：

1. 动态路由参数：
   在定义路由时，可以使用动态路由参数来表示需要传递的参数。在路由路径中使用冒号 `:` 来指定参数名。例如：

   ```javascript
   const routes = [
     {
       path: "/user/:id",
       component: UserComponent,
     },
   ];
   ```

   在进行路由跳转时，可以通过 `router-link` 或编程式导航（如 `router.push()`）来传递参数值。例如：

   ```html
   <router-link :to="'/user/' + userId">User</router-link>
   ```

   在接收参数的组件中，可以通过 `$route.params` 来获取参数值。例如：

   ```javascript
   export default {
     mounted() {
       const id = this.$route.params.id;
       // 使用参数值进行相应的操作
     },
   };
   ```

2. 查询参数：
   另一种方式是使用查询参数来传递参数值。在路由路径后面使用 `?` 符号，并以键值对的形式传递参数。例如：

   ```javascript
   const routes = [
     {
       path: "/user",
       component: UserComponent,
     },
   ];
   ```

   在进行路由跳转时，可以通过 `router-link` 或编程式导航（如 `router.push()`）来传递查询参数。例如：

   ```html
   <router-link :to="{ path: '/user', query: { id: userId } }"
     >User</router-link
   >
   ```

   在接收参数的组件中，可以通过 `$route.query` 来获取查询参数值。例如：

   ```javascript
   export default {
     mounted() {
       const id = this.$route.query.id;
       // 使用参数值进行相应的操作
     },
   };
   ```

## 小程序的路由跳转方式

> 小程序的路由跳转方式有以下几种：
>
> 1. 页面跳转：使用`wx.navigateTo`或`wx.redirectTo`方法进行页面跳转。其中，`navigateTo`会保留当前页面，而`redirectTo`会关闭当前页面。
> 2. 页面重定向：使用`wx.reLaunch`方法进行页面重定向。该方法会关闭所有页面，并打开新的页面。
> 3. 页面返回：使用`wx.navigateBack`方法进行页面返回。可以指定返回的页面数，默认为 1。
> 4. Tab 切换：使用`wx.switchTab`方法进行 Tab 切换。该方法只能用于跳转到带有`tabBar`的页面。
>
> 这些方法都是通过调用小程序提供的 API 来实现路由跳转。具体选择哪种方式取决于您的需求和场景

`wx.navigateTo`和`wx.switchTab`是微信小程序中用于页面跳转的两个常用方法。它们各自有一些缺点需要注意：

1. `wx.navigateTo`的缺点：
   - 页面层级限制：`wx.navigateTo`会将新页面压入页面栈中，导致页面层级增加。小程序中最多只能同时保持 5 个页面的层级关系，超过限制后可能会出现问题。
   - 内存占用：由于新页面被压入页面栈中，而不是替换当前页面，因此每次跳转都会占用额外的内存资源。
2. `wx.switchTab`的缺点：
   - 仅适用于底部导航栏页面：`wx.switchTab`只能用于切换底部导航栏页面，无法用于其他类型的页面跳转。
   - 无法传递参数：`wx.switchTab`无法直接传递参数给目标页面，需要通过其他方式（如本地存储或全局变量）来实现参数传递。

在使用这两个方法时，需要根据具体场景和需求进行选择。如果需要跳转到非底部导航栏页面或需要传递参数，可以使用`wx.navigateTo`。如果需要切换底部导航栏页面且不需要传递参数，可以使用`wx.switchTab`。同时，为了避免页面层级过深导致的问题，建议在不需要返回上一页的情况下使用`wx.redirectTo`来替代`wx.navigateTo`。

## watch 深度监听

在 Vue 中，`watch`选项用于监听数据的变化。默认情况下，`watch`只会对对象的引用进行浅层比较，即只有当被监听的属性本身发生改变时才会触发回调函数。

如果需要深度监听对象或数组的变化，可以使用`deep`选项。将`deep`设置为`true`后，Vue 会递归遍历对象或数组的所有属性，并对每个属性进行深层比较。只要任何一个属性发生变化，都会触发回调函数。

以下是一个示例：

```javascript
data() {
  return {
    obj: {
      prop1: 'value1',
      prop2: 'value2'
    }
  };
},
watch: {
  obj: {
    handler(newVal, oldVal) {
      console.log('obj changed');
    },
    deep: true

  }
}
```

在上述示例中，当`obj`对象的任何属性发生变化时，都会触发`handler`回调函数。

需要注意的是，深度监听可能会带来性能上的损耗，因为 Vue 需要递归遍历对象或数组的所有属性。因此，在使用深度监听时，应该谨慎考虑其影响，并确保只在必要的情况下使用深度监听。另外，Vue 还提供了`immediate`选项，用于在初始渲染时立即执行回调函数，可以根据具体需求进行配置。

## 不改变 CSS 样式的情况下扩大鼠标的点击范围

> 1. 使用透明的覆盖层：创建一个透明的覆盖层，并将其放置在需要扩大点击范围的元素上方。通过设置该覆盖层的宽度和高度来扩大点击区域。然后，使用 JavaScript 监听覆盖层的点击事件，并触发相应的操作。
> 2. 使用伪元素::before 或::after：为需要扩大点击范围的元素添加一个伪元素，如::before 或::after，并设置其宽度和高度来扩大点击区域。然后，使用 JavaScript 监听伪元素的点击事件，并触发相应的操作。
> 3. 用加宽透明 border + margin 负值实现。
> 4. 使用 JavaScript 事件委托：将事件监听器添加到父元素上，然后在事件处理程序中判断点击的位置是否在需要扩大点击范围的元素内部。如果是，则执行相应的操作。

## 瀑布流布局

> 要实现瀑布流布局，可以使用 CSS 的多列布局或 JavaScript 库来实现。

1. 使用 CSS 多列布局：

```html
<style>
  .container {
    column-count: 3; /* 设置为3列 */
    column-gap: 20px; /* 列之间的间距 */
  }

  .item {
    break-inside: avoid; /* 防止元素在列中断开 */
  }
</style>

<div class="container">
  <div class="item">
    <!-- 第一个元素 -->
  </div>
  <div class="item">
    <!-- 第二个元素 -->
  </div>
  <!-- 更多元素... -->
</div>
```

在上述示例中，我们使用`column-count`属性将容器分为 3 列，并使用`column-gap`属性设置列之间的间距。然后，我们给每个子项添加`.item`类名，并使用`break-inside: avoid`属性防止元素在列中断开。

2. 使用 JavaScript 库（如 Masonry.js）：
   首先，您需要引入 Masonry.js 库。然后，您可以按照以下步骤使用它：

- 创建一个包含所有子项的容器元素。
- 初始化 Masonry 实例并指定容器元素。
- 在每次添加、删除或调整子项大小时，调用 Masonry 实例的`layout`方法重新布局。

下面是一个使用 Masonry.js 的示例代码：

```html
<script src="masonry.pkgd.min.js"></script>

<div id="container">
  <div class="item">
    <!-- 第一个元素 -->
  </div>
  <div class="item">
    <!-- 第二个元素 -->
  </div>
  <!-- 更多元素... -->
</div>

<script>
  var container = document.querySelector("#container");
  var masonry = new Masonry(container, {
    itemSelector: ".item",
    columnWidth: 200, // 列宽度
    gutter: 20, // 列之间的间距
  });

  // 添加、删除或调整子项大小后重新布局

  masonry.layout();
</script>
```

在上述示例中，我们使用`itemSelector`属性指定子项的选择器（这里是`.item`），使用`columnWidth`属性设置列宽度，使用`gutter`属性设置列之间的间距。然后，我们创建了一个 Masonry 实例，并将容器元素和选项传递给它。最后，我们可以通过调用`layout`方法来触发布局。

## 微信小程序下拉刷新上拉加载的两种实现方法

> 方法一：onPullDownRefresh 和 onReachBottom 方法实现小程序下拉加载和上拉刷新

首先要在 json 文件里设置 window 属性

| 属性                  | 类型    | 描述                                                                             |
| --------------------- | ------- | -------------------------------------------------------------------------------- |
| enablePullDownRefresh | Boolean | 是否开启下拉刷新，详见页面相关[事件处理](http://www.php.cn/code/5690.html)函数。 |

设置 js 里 onPullDownRefresh 和 onReachBottom 方法

| 属性              | 类型     | 描述                                   |
| ----------------- | -------- | -------------------------------------- |
| onPullDownRefresh | function | 页面相关事件处理函数——监听用户下拉动作 |
| onReachBottom     | function | 页面上拉触发底事件的处理函数           |

当处理完数据刷新后，wx.stopPullDownRefresh 可以停止当前页面的下拉刷新。

> 方法二：在 scroll-view 里设定 bindscrolltoupper 和 bindscrolltolower 实现微信小程序下拉

| 属性              | 类型        | 描述                                       |
| ----------------- | ----------- | ------------------------------------------ |
| bindscrolltoupper | EventHandle | 滚动到顶部/左边，会触发 scrolltoupper 事件 |
| bindscrolltolower | EventHandle | 滚动到底部/右边，会触发 scrolltolower 事件 |

这里要注意，微信的 scroll-view 必须要设置高度才能监听滚动事件，所以，需要在页面的 onLoad 事件中给 scroll-view 的高度赋值

## 十万条数据渲染

> 1. 首先，通过 `setTimeout` 函数将代码放置在一个延迟为 0 毫秒的回调函数中执行。这样可以将代码推迟到下一个事件循环中执行，以避免阻塞主线程。
>
> 2. 在延迟回调函数中，定义了一些变量和常量：
>
>    - `total` 表示要插入的总数据条数，这里设定为 100000 条。
>    - `once` 表示每次插入的数据条数，这里设定为 20 条。
>    - `loopCount` 表示渲染数据需要进行的总次数，即 `total / once`。
>    - `countOfRender` 表示已经完成的渲染次数。
>    - `ul` 是通过 `document.querySelector("ul")` 获取到的 `<ul>` 元素。
>
> 3. 接下来定义了两个函数：
>
>    - `add()` 函数用于向 `<ul>` 元素中插入数据。在每次调用时，通过循环创建 `<li>` 元素，并设置其文本内容为随机生成的整数。然后将这些 `<li>` 元素添加到一个文档片段（`fragment`）中，最后一次性将文档片段添加到 `<ul>` 元素中。这样可以减少回流（reflow）的次数，提高性能。
>    - `loop()` 函数用于控制渲染的次数。如果 `countOfRender` 小于 `loopCount`，则通过 `window.requestAnimationFrame()` 方法调用 `add()` 函数，并在下一帧继续渲染。这样可以将渲染过程分解为多个任务，避免一次性插入大量数据导致页面卡顿。
>
> 4. 最后，在延迟回调函数中，首先调用 `loop()` 函数启动渲染过程，然后代码执行结束。
>
> 总体来说，这段代码通过将数据插入过程拆分为多个小任务，并利用 `requestAnimationFrame` 在每一帧中执行这些任务，以达到优化性能的目的。这种方式可以减少主线程的阻塞时间，提高用户体验。
>
> 进一步优化
>
> 1. 使用虚拟滚动：当列表中有大量数据时，使用虚拟滚动可以只渲染可见区域的部分数据，而不是全部渲染。这样可以显著提高性能和用户体验。
> 2. 使用 Web Worker：如果插入大量数据的操作非常耗时，可以考虑将其放在 Web Worker 中进行处理，以避免阻塞主线程。

```html
<body>
  <ul>
  </ul>
  <script>
    setTimeout(() => {
      // 插⼊十万条数据
      const total = 100000;
      // ⼀次插⼊ 20 条，如果觉得性能不好就减少
      const once = 20;
      // 渲染数据总共需要⼏次
      const loopCount = total / once;
      let countOfRender = 0;
      const ul = document.getElementsByTagName('ul')[0];

      function add() {
        // 优化性能，插入不会造成回流
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < once; i++) {
          const li = document.createElement("li");
          li.innerText = Math.floor(Math.random() * total);
          fragment.appendChild(li);
        }
        ul.appendChild(fragment);
        countOfRender += 1;
        loop();
      }
      function loop() {
        if (countOfRender < loopCount) {
          window.requestAnimationFrame(add);
        }
      }
      loop();
    }, 0);
  </script>
</body>
</html>
```

## Flex 布局，完成三张图片横向排列

> 第一张固定宽度 100px，第二张占满剩下空间的 3/8，第三张占满剩下空间的 5/8

```html
<div class="container">
  <div class="image image1"></div>
  <div class="image image2"></div>
  <div class="image image3"></div>
</div>
```

```css
.container {
  display: flex;
}
.image {
  height: 200px;
}
.image1 {
  width: 100px;
  background-color: red;
}
.image2 {
  flex: 3;
  background-color: green;
}
.image3 {
  flex: 5;
  background-color: blue;
}
```

## 小程序和前端/H5 的区别

小程序是一种轻量级的应用程序，可以在微信、支付宝等平台上运行，而前端开发则是指开发网页的技术和过程。虽然小程序的主要开发语言也是 JavaScript，和网页开发有很多相似之处，但是在实际开发中，小程序和前端开发还是有一些区别的。

1. 渲染线程和脚本线程不同：在网页开发中，渲染线程和脚本线程是互斥的，而在小程序中，它们是分开运行的，分别运行在不同的线程中。这样可以提高小程序的运行效率。
2. 运行环境不同：小程序是在微信、支付宝等平台上运行，而 H5 前端是在浏览器上运行。
3. 开发语言不同：小程序主要使用 WXML、WXSS、JavaScript，而 H5 前端开发使用 HTML、CSS 和 JavaScript。
4. 渲染方式不同：小程序和 H5 前端的渲染方式有区别。小程序使用的是原生渲染，而 H5 前端使用的是浏览器的渲染机制。
5. 开发工具不同：小程序需要使用相应的开发工具进行开发，而 H5 前端则可以使用各种文本编辑器进行开发，例如 VS Code、Sublime Text 等。

## 为什么选择小程序而不选择 H5/app

1. 无需下载安装与 App 相比，小程序无需下载和安装，用户可以直接在微信或其他社交媒体平台中访问，更加便捷和易于使用。
2. 节省空间由于小程序无需下载和安装，它们通常比 App 更小，这意味着它们需要更少的存储空间。
3. 更快的开发和更新：小程序通常使用小程序框架和模板来加速开发，此外，小程序可以直接在云端部署和更新，这些相比 App 更加方便和快速。
4. 更好的用户体验：小程序通常具有更好的用户体验，因为它们可以直接在社交媒体平台中访问，无需下载或者浏览器访问，并且可以使用微信或其他社交媒体平台的功能，例如分享、支付和消息通知等。

<br/>

## H5 和小程序是如何交互的

H5 和小程序之间可以通过 WebViewJavascriptBridge 库实现交互。WebViewJavascriptBridge 库是一个用于 H5 和 Native 应用之间通信的 JavaScript 库，它可以在 Web 页面和 Native 应用之间建立 JavaScript 通信管道，以实现数据传输和方法调用。

## 小程序优化

### **小程序的优化核心就是内存优化**

**Data 数据庞大，导致 jS 到渲染是需要经过 Native 序列化转换的**

利用增量传输优化，小程序原生支持

> 在小程序中实现数据的增量传输优化可以采用以下几种方法：
>
> 1. 使用 Diff 算法：在数据传输过程中，对比前后两次数据的差异，只传输发生变化的部分。这样可以减少传输的数据量，提高传输效率。可以使用一些开源的 Diff 算法库来实现数据的增量传输。
> 2. 压缩数据：对传输的数据进行压缩，减小数据的体积。常见的压缩算法有 Gzip、Deflate 等，可以根据具体需求选择合适的压缩算法进行数据压缩。
> 3. 使用 WebSocket 协议：与传统的 HTTP 请求相比，WebSocket 协议可以建立长连接，并支持双向通信。通过 WebSocket 可以实时传输数据，避免了每次请求都需要建立连接的开销，从而提高传输效率。
> 4. 利用缓存机制：在小程序中可以使用本地缓存来存储已经获取的数据，在下次请求时先检查本地缓存是否存在该数据，如果存在则直接使用缓存数据，避免重复传输相同的数据。
> 5. 服务端推送：通过服务端主动推送数据给小程序，可以实现实时更新数据的功能，避免了小程序主动轮询或请求的开销。
>
> 综合运用上述方法，可以有效地优化小程序数据的传输，减少数据量和传输次数，提高用户体验和性能。具体的实现方式需要根据具体业务需求和技术架构来确定。

## WXSS 与 rpx

**WXSS**是一套样式语言，用于描述 WXML 的组件样式。

WXSS 具有 CSS 大部分特性。与 CSS 相比，WXSS 扩展的**特性**有：

1. 尺寸单位
2. 样式导入

**尺寸单位**
**rpx（responsive pixel）**: 可以根据屏幕宽度进行自适应。规定屏幕宽为**750rpx**。如在 iPhone6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素，1rpx = 0.5px = 1 物理像素。

<br/>

<br/>

## 小程序的性能优化实现

1. 小程序分包加载，按需加载，可以将小程序分成一个主包和多个子包，这样构建时可以打多个包，当用户进入那个页面时加载那个包的内容。
2. 减少代码文件的大小，可以通过减少小程序的代码量、压缩代码、去除无用的代码等方式来实现。
3. 优化小程序的资源加载顺序、使用合适的图片格式、减少网络请求。
4. 减少 setData 接口的调用频率，setData 接口的调用涉及逻辑层与渲染层间的线程通信，通信过于频繁可能导致导致卡顿。
5. 减少小程序的页面数量、减少页面中的 dom 数目、优化小程序的布局结构等方式来实现减少页面渲染时间。

<br/>

<br/>

## 移动端适配方案

1. 媒体查询方案：通过 CSS3 中的媒体查询功能，根据不同的屏幕尺寸和分辨率，为网站设置不同的样式。
2. rem 布局方案：通过将网站中的尺寸值都转换为相对于根元素的 rem 单位，以实现网站在不同设备上的自适应。
3. Viewport 方案：通过设置 viewport 元标签的属性，以适应不同的设备屏幕。

<br/>

<br/>

## 前端如何根据 UI 进行设计

1. 页面布局：根据 UI 设计稿中的布局要求，使用 HTML 和 CSS 来实现页面的布局。常用的布局方式有 Flex 布局、Grid 布局、响应式布局等。
2. 字体、颜色、图标等：根据 UI 设计稿中的字体、颜色、图标等要求，使用 CSS 来设置相应的样式。常用的字体单位有 px、em、rem 等。使用图标时可以使用字体图标、SVG 图标、图片等方式。
3. 动画效果：根据 UI 设计稿中的动画效果要求，使用 CSS 动画、JavaScript 动画等方式来实现相应的动画效果。
4. 响应式设计：根据 UI 设计稿中的响应式要求，使用媒体查询、rem 布局等方式来实现响应式设计。

<br/>

<br/>

## 前端优化

### 页面渲染优化

1. 减少页面重绘和回流；

   > **重绘**：指的是浏览器只需要重新绘制元素的样式、颜色等外观的过程，而不需要重新计算位置和大小。
   >
   > **回流**：指的是浏览器重新计算元素的位置和大小，然后重新绘制到屏幕上的过程。
   >
   > 减少使用 css 属性简写。因为 css 简写把所有值初始化为 initial，尽量不使用属性简写可以最小化重绘(repaint)和回流(reflow)
   >
   > 在大量修改元素样式时，可以先用 display： none 将其隐藏，修改完再设置为 display： block，这样只会造成两次回流；
   >
   > 不使用 table 布局（table 元素一旦触发回流就会导致 table 里所有的其它元素回流）；
   >
   > 通过修改 className 批量修改元素样式；

2. 图片压缩，采用精灵图；

   > 转换图片格式成 WebP 格式，通常有两种方式：cwebp 命令行工具和 Imagemin WebP 插件。如果你的项目比较简单或者你仅需要将图片转化一次，则选择 cwebp 命令行工具；而如果你使用构建工具比如 Webpack 去构建项目时，那就选择使用 Imagemin WebP 插件。

3. 图片懒加载；

   > **懒加载**： 简言之就是只有当图片出现在浏览器的可视区域内时，才加载图片让图片显示出来。
   > 判断图片出现在浏览器可视区域的方法：图片距离顶部的高度（offsetTop） - 页面被卷去的高度（scrollTop） 〈= 浏览器的可视区域的高度（innerHeight）

4. v-if 和 v-show 区分使用场景；

   > v-if 在切换过程中条件块内的事件监听器和子组件会被销毁和重建；
   > v-show 只是简单地基于 CSS 的 display 属性进行切换。
   > 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。

5. v-for 遍历必须为 item 添加 key，且避免同时使用 v-if

   > （1）v-for 遍历必须为 item 添加 key
   > 在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue 精准找到该条列表数据，且当数据更新时能较快地定位。
   >
   > （2）v-for 遍历避免同时使用 v-if
   > v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度。

6. keep-alive 缓存页面

   > 避免重复创建组件实例，且能保留缓存组件状态

7. 事件的销毁；

   > Vue 组件销毁时，我们需要手动移除相应的事件监听，以免造成内存泄露。

### 打包优化

1. webpack 缩小打包域

   > 在使用 loader 的时候，可以借助 include 和 exclude 这两个参数，规定 loader 哪些需要哪些不需要。

2. webpack 优化 resolve.extensions 配置

   > 在源码中写导入语句时，要尽可能的带上后缀，从而可以避免寻找过程，减少寻找时间。

3. 对图片进行压缩

   > 使用 image-webpack-loader 来压缩图片，将小图片转为 base64 格式，来减少浏览器发送网络请求，从而减少响应时间。

4. 模板预编译

   > 使用 vue-template-loader，在构建过程中把模板文件转换成为 JavaScript 渲染函数。

5. thread-loader

   > 使用 thread-loader，将 thread-loader 放在比较费时间的 loader 之前，比如 babel-loader。实现多进程打包，可以大大提高构建的速度。

6. 利用 plugin 对 HTML、JS、CSS 进行压缩

7. 减少 ES6 转为 ES5 的冗余代码

8. tree shaking

   > 它是用来清除我们项目中的一些无用代码，它依赖于 ES 中模块的静态语法分析实现。先标记出没有被动用过模块导出值，然后利用 Terser 删除掉这些没被用到的导出代码。

### 总体优化

1. SSR 服务端渲染

   > 服务端渲染。它指的是 HTML 页面渲染过程在服务端完成，最终的渲染结果通过 HTTP 协议发送给客户端。
   > SSR 主要带来的好处就是 SEO 和首屏加载速度大大提高。

2. 开启 gzip 压缩

   > 文件进行压缩，能大大提高首屏加载速度，对于纯文本文件我们可以至少压缩到原大小的 40%

3. 组件按需引入

   > 使用第三方组件库时，要按需引入，例如 import { Button } from 'vant';

4. 动态加载

   > 使用 import()动态引入的语法引入一些第三方库和组件

5. 组件异步加载

   > 组件异步加载有两种方式：
   >
   > // 1. import 懒加载
   > () => import('@/pages/xxx.vue')
   > // 2. 使用 require
   > resolve => require(['@/pages/xxx.vue'], resolve),

6. 路由懒加载

   > 路由懒加载是组件异步加载的运用：
   > //routes
   > {
   > path: '/index',
   > name: 'index',
   > component: () => import('@view/xxx.vue'),
   > //或者 component: require(['@/view/xxx.vue'], resolve),
   > meta: { title: '首页' }
   > }

7. CDN 内容分发

   > 即内容分发网络。静态文件，音频，视频，js 资源，图片等都可以放 CDN 上，加快资源的获取速度。

<br/>

## 懒加载/预加载 在项目中的实现

### 懒加载

在实现懒加载时，通常需要使用 JS 来监听滚动事件，并判断页面中的资源是否需要加载。以下是一个基本的懒加载实现方式：
在 HTML 中，可以使用 data-src 属性来存储图片的地址，src 属性用于显示占位图。使用 JavaScript 来监听滚动事件，并判断页面中的图片是否需要加载。获取图片元素相对于视口的位置，如果图片元素的顶部位置小于窗口的高度，就将图片的 data-src 属性设置为 src 属性，以实现图片的加载。

### 预加载

**预加载**：首先获取图片元素的 data-src 属性，然后创建一个 Image 对象，并使用 onload 事件来监听图片的加载完成事件。在图片加载完成后，将图片的 data-src 属性设置为 src 属性，以实现图片的加载

<br/>

<br/>

## CDN

**CDN**：即 Content Delivery Network，内容分发网络，是一种利用互联网技术实现用户就近访问的高效网络分发平台。用户访问时根据所在线路与位置，就近选择最快的服务器节点，然后从缓存中取出相应内容，避免了直接从源站拉取资源，减低了网络阻塞。

<br/>

<br/>

## 预处理及其功能

LESS 和 SCSS 都是动态样式语言，它们都提供了一些 CSS 不具备的功能，例如变量、嵌套、运算、混合、继承、颜色处理和函数等。

在 LESS 中，变量以“@”开头，而在 SCSS 中，变量以“$”开头。Sass 的功能比 LESS 更强大，Sass 提供了四种输出选项（嵌套、展开、简洁和压缩），而 LESS 没有输出设置。此外，Sass 还支持 if/else 条件语句和 for 循环语句，而 LESS 不支持条件语句。

<br/>

<br/>

## 跨域

跨域指的是在浏览器中，当前网页所在的域名与请求的资源所在的域名不一致，即跨域请求。跨域请求是由于浏览器的同源策略所导致的。同源策略是浏览器的一种安全策略，它限制了一个源加载的文档或脚本与另一个源的资源进行的交互。同源是指协议、域名、端口号完全相同，只要有一个不同就是跨域。

**解决方案**

1. JSONP：是一种跨域访问的解决方案。它通过动态创建 script 标签，以 script 标签的方式来获取数据。因为 script 标签的 src 属性可以跨域访问，所以通过在 URL 中添加一个 callback 参数来指定回调函数名，服务器返回的数据将被封装在回调函数中，并作为参数传入到回调函数中，从而实现跨域访问。
2. CORS：是一种跨域资源共享的解决方案。它是一种基于 HTTP 头部的机制，用于让服务器能够访问指定域名的浏览器请求。
3. 代理：通过在同源域名下设置一个代理服务器来转发请求，从而实现跨域访问。
4. nginx 反向代理：通过在同源域名下设置一个 nginx 反向代理服务器来转发请求，从而实现跨域访问。

<br/>

<br/>

## 事件委托

事件委托（Event Delegation）是一种常用的事件处理技术，它利用了事件冒泡的原理，将事件处理程序绑定在父元素上，从而减少了事件处理程序的数量，提高了性能。事件委托的基本思想是将事件处理程序绑定在父元素上，然后根据事件目标的不同，执行不同的操作。这样一来，就可以利用事件冒泡机制，将事件处理程序委托给父元素来处理，从而避免了为每个子元素都添加事件处理程序的麻烦

<br/>

<br/>

## TCP 和 UDP

TCP(Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

UDP(User Datagram Protocol 用户数据报协议）是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。

**区别**

1. TCP 是面向连接的传输控制协议，而 UDP 提供了无链接的数据报服务/类似电话与短信
2. TCP 面向连接，提供可靠的数据服务
3. TCP 首部开销 20 字节，UDP 首部开销 8 字节
4. TCP 逻辑通信信道是全双工的可靠信道，UDP 的通讯信道则是不可靠信道。
5. UDP 没有拥塞机制，因此网络出现拥堵不会使源主机的发送效率降低（有利于实时会议视
   等）
6. TCP 的连接只能是点到点的，UDP 支持一对一，多对一，多对多的交互通信

**TCP 的拥塞控制**：TCP 拥塞控制是 TCP 协议中用于避免网络拥塞的一种机制。TCP 拥塞控制机制主要包括四个算法：慢启动、拥塞避免、快重传和快恢复。

<br/>

## 滑动窗口

滑动窗口（Sliding Window）是一种用于流量控制和拥塞控制的技术，常用于 TCP 协议中。滑动窗口可以看作是发送方和接收方之间的一个缓存区，接收方通过告知发送方自己的缓存区大小，从而控制发送方发送数据的速度。具体来说，滑动窗口通过维护一个发送窗口和一个接收窗口来实现流量控制和拥塞控制。

<br/>

## let const var 区别

1. 变量作用域区别：var 声明的变量作用域为函数作用域或全局作用域，而 let 和 const 声明的变量作用域为块级作用域，使用 let 和 const 声明的变量更加安全，可以避免因作用域泄漏而导致的错误。
2. 变量声明提升区别：var 声明的变量存在变量声明提升，即变量可以在声明之前使用，但其值为 undefined。而 let 和 const 声明的变量不存在变量声明提升，如果在声明之前使用，会抛出错误。
3. 变量重新赋值区别：let 声明的变量可以被重新赋值，而 const 声明的变量不能被重新赋值，一旦赋值后就不能再修改。const 声明的变量必须在声明时进行初始化，否则会抛出错误。

<br/>

## 匿名函数和箭头函数

**匿名函数**：匿名函数是指没有名称的函数，可以通过函数表达式或函数声明的方式定义。匿名函数通常用于作为回调函数、自执行函数或模块模式等场景。

**箭头函数**：箭头函数是 ES6 中引入的一种新的函数定义方式，语法更加简洁，可以自动绑定 this 关键字。箭头函数通常用于简化代码、避免 this 关键字指向错误等场景。

**特点：**

1. 可以作为函数参数或返回值；
2. 可以访问外部作用域的变量；
3. 可以使用 arguments 关键字访问函数参数；
4. 可以使用 rest 参数语法来接收不定数量的参数；
5. 可以使用默认参数语法来设置函数参数的默认值。

<br/>

## Https 安全与安全证书

HTTPS（Hypertext Transfer Protocol Secure）是一种基于 TLS/SSL 协议的加密传输协议，用于保障 Web 安全。HTTPS 协议通过使用 SSL/TLS 协议来建立加密连接，从而保护传输的数据不被窃听、篡改或伪造。它主要通过以下方式来保证安全性：

1. 数据加密：HTTPS 使用 SSL/TLS 协议对传输的数据进行加密，可以防止中间人攻击和窃听。SSL/TLS 协议使用对称密钥加密和非对称密钥加密相结合的方式，确保数据在传输过程中不被篡改或窃取。
2. SSL/TLS 握手过程：在 SSL/TLS 握手过程中，客户端和服务器之间会交换数字证书，并使用公钥加密算法（如 RSA、DSA 等）来建立安全连接。客户端会验证服务器的数字证书是否合法和有效。如果验证通过，就会生成一个共享密钥，用于后续的数据加密和解密。

<br/>

## CSS 样式污染

**CSS 样式污染**指的是当一个网站中使用了第三方的组件或样式时，这些组件或样式可能会影响到当前网站的样式，导致样式出现异常或冲突的问题。CSS 样式污染可能会导致页面布局错乱、样式失效、漏洞等安全问题。

以下是几种解决 CSS 样式污染的方法：

1. 命名空间：使用命名空间可以避免不同组件之间的样式冲突。在 CSS 中，可以使用命名空间来限定样式的作用范围，避免不同组件之间的样式冲突。
2. Shadow DOM：使用 Shadow DOM 可以将组件的样式和 HTML 结构封装在一起，避免组件的样式影响到其他组件或页面。在使用 Shadow DOM 时，可以使用 :host 伪类来指定组件的样式。
3. CSS Modules：使用 CSS Modules 可以将样式作用域限定在组件内部，避免样式冲突。在使用 CSS Modules 时，每个组件的样式都会被编译成唯一的类名，避免了样式冲突的问题。

<br/>

## CSS 怎么实现垂直居中、水平居中

**垂直居中**

1. 使用 flex 布局：将父容器设置为 flex 布局，然后使用 align-items 和 justify-content 属性来垂直居中子元素。
2. 使用绝对定位：将子元素设置为绝对定位，然后使用 top 和 transform 属性来垂直居中。
3. 使用 table 布局：将父容器设置为 table 布局，然后将子元素设置为 table-cell 布局，使用 vertical-align 属性来垂直居中。

**水平居中**

1. 使用 flex 布局：将父容器设置为 flex 布局，然后使用 align-items 和 justify-content 属性来水平居中子元素。
2. 使用绝对定位：将子元素设置为绝对定位，然后使用 left 和 transform 属性来水平居中。
3. 使用 text-align 属性：将父元素设置为 text-align: center，然后将子元素设置为 display: inline-block。
4. 将元素设置为块级元素，然后将左右 margin 设置为 auto，即可实现元素水平居中。

## 自适应布局和响应式布局的实现

在实现上，自适应布局是使用媒体查询技术，通过为每个屏幕分辨率定义不同的 CSS 样式表，使页面在不同设备上呈现不同的布局。而响应式布局则是创建多个流体式布局（百分比布局），每个布局对应一个屏幕分辨率范围，通过媒体查询技术来更改流式布局。

<br/>

## position 属性

1. absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。
2. fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。 元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。
3. relative：生成相对定位的元素，相对于其正常位置进行定位。 因此，"left:20" 会向元素的 left 位置添加 20 像素。
4. sticky：CSS3 新增，粘性定位，而当页面滚动超出目标区域时，它的表现就像 position:fixed，它会固定在目标位置。
5. static：默认值。没有定位，元素出现在正常的流中 （忽略 left、top、right、bottom 或者 z-index 声明）。
6. inherit：规定应该从父元素继承 position 属性的值。

## 图片格式

前端开发的常见图片格式有以下几种：

1. JPEG（.jpg）：一种有损压缩的格式。
2. PNG（.png）：一种无损压缩的格式。PNG 格式支持透明度，可以实现半透明效果。
3. GIF（.gif）：一种支持动画的格式，适合存储简单的动画和图标。GIF 还支持透明度。
4. SVG（.svg）：一种矢量图形格式，适合存储图标和简单的矢量图形。
5. Webp（.webp）一种压缩图形格式，WebP 格式支持有损和无损压缩，同时还支持透明度和动画。但由于它是相对较新的格式，浏览器兼容性较差。

**base64 编码**

Base64 编码是一种将二进制数据转换成 ASCII 字符的编码方式。在前端开发中，Base64 编码通常用于将图片等二进制数据嵌入到 HTML、CSS 或 JavaScript 代码中，以减少请求次数，提高网站性能。

1. 通过 HTML 的<input>元素获取用户选择的图片文件。
2. 创建 FileReader 对象。
3. 通过 FileReader 对象的 readAsDataURL()方法将图片文件读取为 Base64 编码。
4. 在 FileReader 对象的 onload 事件回调函数中获取 Base64 编码

<br/>

## XSS 攻击和 CSRF 攻击

**XSS**：跨站脚本攻击，恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页面时，嵌入 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。

**CSRF**：跨站请求伪造，它允许攻击者利用用户已登录的身份，向 Web 服务器发送恶意请求。CSRF 攻击通常会导致用户的隐私泄露、账号被盗用等问题。

## 前端鉴权

**前端鉴权**：是指在前端进行用户身份认证和权限验证。前端鉴权主要用于保护用户的隐私和数据安全，防止未授权的用户进行非法操作。前端鉴权通常分为两种类型：路由鉴权和接口鉴权。

**路由鉴权**：是指在前端进行页面跳转时，根据用户的身份和权限判断是否允许访问该页面。通常使用 JWT（JSON Web Token）等机制，验证用户的身份和权限。

**接口鉴权**：是指在前端向后端发送请求时，根据用户的身份和权限判断是否允许访问该接口。接口鉴权通常需要在前端发送请求时携带用户的身份和权限信息，通常在请求头中添加 Authorization 等字段。

## 登录功能的实现

登录功能的实现大致可分成 6 步：

1. 前端验证用户输入是否符合规范，并将账号密码用公钥进行加密；
2. 前端调用后端登录接口，向后端发起登录请求；
3. 后端收到请求，通过私钥解密后查验数据库中是否有相应账号以及密码是否正确；
4. 验证通过后，将成功信息连同 token 一起发送给前端；
5. 前端将 token 储存起来，此后每次用户进入需要登录才能访问的页面时向后端发送 token；
6. 后端验证 token 是否正确，若未过期，这允许用户能进行访问，若过期，则清除用户信息，回到未登录状态。
